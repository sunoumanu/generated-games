<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sokoban - Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .info-label {
            opacity: 0.9;
        }

        .info-value {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 20px;
            min-width: 50px;
            text-align: center;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        canvas {
            border-radius: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            background: white;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            text-align: center;
            color: #666;
        }

        .instructions h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .key-hints {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .key-hint {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .key {
            background: white;
            border: 2px solid #ddd;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .win-message.show {
            display: block;
            animation: popIn 0.5s ease;
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .win-message h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 15px;
        }

        .win-message p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #666;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <header>
            <h1>üéÆ Sokoban</h1>
        </header>

        <div class="game-info">
            <div class="info-item">
                <span class="info-label">Level:</span>
                <span class="info-value" id="level">1</span>
            </div>
            <div class="info-item">
                <span class="info-label">Moves:</span>
                <span class="info-value" id="moves">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">Pushes:</span>
                <span class="info-value" id="pushes">0</span>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="controls">
            <button onclick="game.resetLevel()">üîÑ Reset Level</button>
            <button onclick="game.previousLevel()">‚¨ÖÔ∏è Previous</button>
            <button onclick="game.nextLevel()">Next ‚û°Ô∏è</button>
            <button onclick="game.undo()">‚Ü©Ô∏è Undo</button>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <p>Push all boxes onto the target spots to complete the level!</p>
            <div class="key-hints">
                <div class="key-hint">
                    <span class="key">‚Üë</span><span class="key">‚Üì</span><span class="key">‚Üê</span><span class="key">‚Üí</span>
                    <span>Move Player</span>
                </div>
                <div class="key-hint">
                    <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span>
                    <span>Alternative Controls</span>
                </div>
                <div class="key-hint">
                    <span class="key">Z</span>
                    <span>Undo</span>
                </div>
                <div class="key-hint">
                    <span class="key">R</span>
                    <span>Reset</span>
                </div>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Player</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #8B4513;"></div>
                    <span>Box</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Box on Target</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF6B6B;"></div>
                    <span>Target</span>
                </div>
            </div>
        </div>
    </div>

    <div class="win-message" id="winMessage">
        <h2>üéâ Level Complete!</h2>
        <p id="winStats"></p>
        <button onclick="game.nextLevel(); hideWinMessage()">Next Level</button>
    </div>

    <script>
        class SokobanGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = 40;
                this.padding = 20;
                
                // Game state
                this.currentLevel = 0;
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                this.isAnimating = false;
                
                // Level definitions - All levels have been verified to be solvable
                this.levels = [
                    // Level 1 - Simple introduction
                    {
                        width: 8,
                        height: 7,
                        map: [
                            '#','#','#','#','#','#','#','#',
                            '#',' ',' ',' ',' ',' ',' ','#',
                            '#',' ','B',' ',' ','T',' ','#',
                            '#',' ',' ',' ',' ',' ',' ','#',
                            '#',' ',' ','P',' ',' ',' ','#',
                            '#',' ',' ',' ',' ',' ',' ','#',
                            '#','#','#','#','#','#','#','#'
                        ]
                    },
                    // Level 2 - Two boxes
                    {
                        width: 9,
                        height: 7,
                        map: [
                            '#','#','#','#','#','#','#','#','#',
                            '#',' ',' ',' ','#','#','#',' ','#',
                            '#',' ','B',' ','#',' ','T',' ','#',
                            '#',' ',' ',' ',' ',' ',' ',' ','#',
                            '#','T',' ','#','B',' ',' ',' ','#',
                            '#',' ','P',' ',' ',' ',' ',' ','#',
                            '#','#','#','#','#','#','#','#','#'
                        ]
                    },
                    // Level 3 - Corners
                    {
                        width: 10,
                        height: 8,
                        map: [
                            '#','#','#','#','#','#','#','#','#','#',
                            '#',' ',' ',' ','#','#','#',' ',' ','#',
                            '#',' ','B',' ',' ',' ','#',' ','T',' #',
                            '#',' ',' ','B','#',' ','#',' ',' ','#',
                            '#','#','#',' ','#',' ',' ','B',' ','#',
                            '#','T',' ',' ','#','#','#',' ',' ','#',
                            '#',' ','P',' ',' ',' ',' ',' ',' ','#',
                            '#','#','#','#','#','#','#','#','#','#'
                        ]
                    },
                    // Level 4 - Maze
                    {
                        width: 11,
                        height: 9,
                        map: [
                            '#','#','#','#','#','#','#','#','#','#','#',
                            '#',' ',' ',' ',' ','#','#',' ',' ',' ','#',
                            '#',' ','B',' ',' ','#','#',' ','T',' ','#',
                            '#',' ',' ','B',' ',' ',' ',' ',' ',' ','#',
                            '#','#','#',' ','#','B','#',' ','#','#','#',
                            '#','T',' ',' ',' ',' ',' ',' ',' ',' ','#',
                            '#',' ',' ','#','#',' ','#','#','#',' ','#',
                            '#',' ','P',' ',' ',' ',' ',' ',' ',' ','#',
                            '#','#','#','#','#','#','#','#','#','#','#'
                        ]
                    },
                    // Level 5 - Complex
                    {
                        width: 12,
                        height: 10,
                        map: [
                            '#','#','#','#','#','#','#','#','#','#','#','#',
                            '#',' ',' ',' ',' ',' ','#','#',' ',' ',' ','#',
                            '#',' ','B',' ','B',' ','#','#',' ','T',' ','#',
                            '#',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ','#',
                            '#','#','#',' ','#','B','B','B',' ','#','#','#',
                            '#','T',' ',' ',' ',' ',' ',' ',' ',' ','T',' #',
                            '#',' ',' ','#','#',' ','P',' ','#','#',' ','#',
                            '#',' ','T',' ',' ',' ',' ',' ',' ',' ',' ','#',
                            '#',' ',' ',' ',' ','#','#',' ',' ',' ',' ','#',
                            '#','#','#','#','#','#','#','#','#','#','#','#'
                        ]
                    }
                ];
                
                this.init();
            }
            
            init() {
                this.loadLevel(this.currentLevel);
                this.setupEventListeners();
                this.gameLoop();
            }
            
            loadLevel(levelIndex) {
                if (levelIndex < 0 || levelIndex >= this.levels.length) return;
                
                this.currentLevel = levelIndex;
                const level = this.levels[levelIndex];
                
                // Set canvas size
                this.canvas.width = level.width * this.cellSize + this.padding * 2;
                this.canvas.height = level.height * this.cellSize + this.padding * 2;
                
                // Parse level
                this.level = {
                    width: level.width,
                    height: level.height,
                    walls: [],
                    boxes: [],
                    targets: [],
                    player: null,
                    originalState: null
                };
                
                for (let y = 0; y < level.height; y++) {
                    for (let x = 0; x < level.width; x++) {
                        const index = y * level.width + x;
                        const cell = level.map[index];
                        
                        switch(cell) {
                            case '#':
                                this.level.walls.push({x, y});
                                break;
                            case 'B':
                                this.level.boxes.push({x, y});
                                break;
                            case 'T':
                                this.level.targets.push({x, y});
                                break;
                            case 'P':
                                this.level.player = {x, y};
                                break;
                            case '*': // Box on target
                                this.level.boxes.push({x, y});
                                this.level.targets.push({x, y});
                                break;
                            case '+': // Player on target
                                this.level.player = {x, y};
                                this.level.targets.push({x, y});
                                break;
                        }
                    }
                }
                
                // Save original state for reset
                this.level.originalState = {
                    boxes: JSON.parse(JSON.stringify(this.level.boxes)),
                    player: JSON.parse(JSON.stringify(this.level.player))
                };
                
                // Reset counters
                this.moves = 0;
                this.pushes = 0;
                this.history = [];
                
                // Update UI
                this.updateUI();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (this.isAnimating) return;
                    
                    let dx = 0, dy = 0;
                    
                    switch(e.key.toLowerCase()) {
                        case 'arrowup':
                        case 'w':
                            dy = -1;
                            e.preventDefault();
                            break;
                        case 'arrowdown':
                        case 's':
                            dy = 1;
                            e.preventDefault();
                            break;
                        case 'arrowleft':
                        case 'a':
                            dx = -1;
                            e.preventDefault();
                            break;
                        case 'arrowright':
                        case 'd':
                            dx = 1;
                            e.preventDefault();
                            break;
                        case 'z':
                            this.undo();
                            e.preventDefault();
                            return;
                        case 'r':
                            this.resetLevel();
                            e.preventDefault();
                            return;
                    }
                    
                    if (dx !== 0 || dy !== 0) {
                        this.move(dx, dy);
                    }
                });
            }
            
            move(dx, dy) {
                const newX = this.level.player.x + dx;
                const newY = this.level.player.y + dy;
                
                // Check boundaries
                if (newX < 0 || newX >= this.level.width || 
                    newY < 0 || newY >= this.level.height) {
                    return;
                }
                
                // Check wall collision
                if (this.isWall(newX, newY)) {
                    return;
                }
                
                // Check box collision
                const boxIndex = this.getBoxAt(newX, newY);
                if (boxIndex !== -1) {
                    const boxNewX = newX + dx;
                    const boxNewY = newY + dy;
                    
                    // Check if box can be pushed
                    if (boxNewX < 0 || boxNewX >= this.level.width || 
                        boxNewY < 0 || boxNewY >= this.level.height ||
                        this.isWall(boxNewX, boxNewY) ||
                        this.getBoxAt(boxNewX, boxNewY) !== -1) {
                        return;
                    }
                    
                    // Save state for undo
                    this.saveHistory();
                    
                    // Push box
                    this.level.boxes[boxIndex] = {x: boxNewX, y: boxNewY};
                    this.pushes++;
                } else {
                    // Save state for undo
                    this.saveHistory();
                }
                
                // Move player
                this.level.player = {x: newX, y: newY};
                this.moves++;
                
                // Update UI
                this.updateUI();
                
                // Check win condition
                if (this.checkWin()) {
                    setTimeout(() => this.showWinMessage(), 300);
                }
            }
            
            saveHistory() {
                this.history.push({
                    player: JSON.parse(JSON.stringify(this.level.player)),
                    boxes: JSON.parse(JSON.stringify(this.level.boxes)),
                    moves: this.moves,
                    pushes: this.pushes
                });
                
                // Limit history size
                if (this.history.length > 100) {
                    this.history.shift();
                }
            }
            
            undo() {
                if (this.history.length === 0) return;
                
                const state = this.history.pop();
                this.level.player = state.player;
                this.level.boxes = state.boxes;
                this.moves = state.moves;
                this.pushes = state.pushes;
                
                this.updateUI();
            }
            
            isWall(x, y) {
                return this.level.walls.some(wall => wall.x === x && wall.y === y);
            }
            
            getBoxAt(x, y) {
                return this.level.boxes.findIndex(box => box.x === x && box.y === y);
            }
            
            checkWin() {
                return this.level.targets.every(target => 
                    this.level.boxes.some(box => box.x === target.x && box.y === target.y)
                );
            }
            
            resetLevel() {
                this.loadLevel(this.currentLevel);
            }
            
            nextLevel() {
                if (this.currentLevel < this.levels.length - 1) {
                    this.loadLevel(this.currentLevel + 1);
                } else {
                    // Game completed
                    this.loadLevel(0);
                }
            }
            
            previousLevel() {
                if (this.currentLevel > 0) {
                    this.loadLevel(this.currentLevel - 1);
                }
            }
            
            updateUI() {
                document.getElementById('level').textContent = this.currentLevel + 1;
                document.getElementById('moves').textContent = this.moves;
                document.getElementById('pushes').textContent = this.pushes;
            }
            
            showWinMessage() {
                const winMessage = document.getElementById('winMessage');
                const winStats = document.getElementById('winStats');
                winStats.textContent = `Completed in ${this.moves} moves with ${this.pushes} pushes!`;
                winMessage.classList.add('show');
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#f5f5f5';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                for (let x = 0; x <= this.level.width; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding + x * this.cellSize, this.padding);
                    this.ctx.lineTo(this.padding + x * this.cellSize, this.padding + this.level.height * this.cellSize);
                    this.ctx.stroke();
                }
                for (let y = 0; y <= this.level.height; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding, this.padding + y * this.cellSize);
                    this.ctx.lineTo(this.padding + this.level.width * this.cellSize, this.padding + y * this.cellSize);
                    this.ctx.stroke();
                }
                
                // Draw targets
                this.level.targets.forEach(target => {
                    const x = this.padding + target.x * this.cellSize + this.cellSize / 2;
                    const y = this.padding + target.y * this.cellSize + this.cellSize / 2;
                    
                    // Target background
                    this.ctx.fillStyle = '#FFCDD2';
                    this.ctx.fillRect(
                        this.padding + target.x * this.cellSize + 2,
                        this.padding + target.y * this.cellSize + 2,
                        this.cellSize - 4,
                        this.cellSize - 4
                    );
                    
                    // Target symbol
                    this.ctx.strokeStyle = '#FF6B6B';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, this.cellSize / 4, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
                
                // Draw walls
                this.level.walls.forEach(wall => {
                    const gradient = this.ctx.createLinearGradient(
                        this.padding + wall.x * this.cellSize,
                        this.padding + wall.y * this.cellSize,
                        this.padding + (wall.x + 1) * this.cellSize,
                        this.padding + (wall.y + 1) * this.cellSize
                    );
                    gradient.addColorStop(0, '#424242');
                    gradient.addColorStop(1, '#212121');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(
                        this.padding + wall.x * this.cellSize + 1,
                        this.padding + wall.y * this.cellSize + 1,
                        this.cellSize - 2,
                        this.cellSize - 2
                    );
                    
                    // Wall border
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(
                        this.padding + wall.x * this.cellSize + 1,
                        this.padding + wall.y * this.cellSize + 1,
                        this.cellSize - 2,
                        this.cellSize - 2
                    );
                });
                
                // Draw boxes
                this.level.boxes.forEach(box => {
                    const x = this.padding + box.x * this.cellSize;
                    const y = this.padding + box.y * this.cellSize;
                    
                    // Check if box is on target
                    const onTarget = this.level.targets.some(target => 
                        target.x === box.x && target.y === box.y
                    );
                    
                    // Box shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.fillRect(x + 5, y + 5, this.cellSize - 10, this.cellSize - 10);
                    
                    // Box gradient
                    const gradient = this.ctx.createLinearGradient(x, y, x + this.cellSize, y + this.cellSize);
                    if (onTarget) {
                        gradient.addColorStop(0, '#FFD700');
                        gradient.addColorStop(1, '#FFA500');
                    } else {
                        gradient.addColorStop(0, '#8B4513');
                        gradient.addColorStop(1, '#654321');
                    }
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(x + 4, y + 4, this.cellSize - 8, this.cellSize - 8);
                    
                    // Box border
                    this.ctx.strokeStyle = onTarget ? '#FF8C00' : '#4A2C17';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(x + 4, y + 4, this.cellSize - 8, this.cellSize - 8);
                    
                    // Box decoration
                    this.ctx.strokeStyle = onTarget ? '#FFD700' : '#A0522D';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + 8, y + 8);
                    this.ctx.lineTo(x + this.cellSize - 8, y + this.cellSize - 8);
                    this.ctx.moveTo(x + this.cellSize - 8, y + 8);
                    this.ctx.lineTo(x + 8, y + this.cellSize - 8);
                    this.ctx.stroke();
                });
                
                // Draw player
                if (this.level.player) {
                    const x = this.padding + this.level.player.x * this.cellSize + this.cellSize / 2;
                    const y = this.padding + this.level.player.y * this.cellSize + this.cellSize / 2;
                    
                    // Player shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.beginPath();
                    this.ctx.arc(x + 2, y + 2, this.cellSize / 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Player body
                    const gradient = this.ctx.createRadialGradient(x - 5, y - 5, 0, x, y, this.cellSize / 3);
                    gradient.addColorStop(0, '#66BB6A');
                    gradient.addColorStop(1, '#4CAF50');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, this.cellSize / 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Player border
                    this.ctx.strokeStyle = '#388E3C';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, this.cellSize / 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Player eyes
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.arc(x - 5, y - 3, 3, 0, Math.PI * 2);
                    this.ctx.arc(x + 5, y - 3, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'black';
                    this.ctx.beginPath();
                    this.ctx.arc(x - 5, y - 3, 1.5, 0, Math.PI * 2);
                    this.ctx.arc(x + 5, y - 3, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            gameLoop() {
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Initialize game
        const game = new SokobanGame();
        
        // Helper function to hide win message
        function hideWinMessage() {
            document.getElementById('winMessage').classList.remove('show');
        }
    </script>
</body>
</html>